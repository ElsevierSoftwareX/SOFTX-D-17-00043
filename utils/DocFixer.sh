#!/bin/bash
# ******************************************************************************
# Copyright (c) 2015 UT-Battelle, LLC.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#   Jordan H. Deyton - Initial API and implementation and/or initial documentation
#
# ******************************************************************************

# This script can be used to clean up the documentation in Java source files.
# It can either be used in an interactive mode (changes to a file must be
# confirmed) or automatically (all files are processed). Changes made to files
# are printed to STDERR.

# Create a message to describe the script.
msg="\nThis script cleans the following from source code documentation:\n\n  1 - // begin-user-code\n  2 - // end-user-code\n  3 - <!-- begin-UML-doc -->\n  4 - <!-- end-UML-doc -->\n  5 - @generated \"UML to Java ...\"\n"
echo -e $msg

# This is a convenient function to ask a yes/no question and get a response.
# The first argument (if available) is the prompt question, which will
# automatically have a (Y/N) added after it. The function will not return until
# a Y, y, N, or n is entered. The result variable is set to true if yes, false 
# if no. This function also returns 0 for true and 1 for false.
result=false
function promptYesNo {
    # Get the prompt question. If none is specified, use a default prompt.
    local prompt="Are you sure?"
    if [[ $1 ]]; then
        prompt=$1
    fi
    # Prompt until a valid response is received (can be interrupted).
    result=false
    while read -p "$prompt (Y/N)" -r -n 1 -s answer; do
        echo
        if [[ $answer = [Yy] ]]; then
            result=true
            return 0
        elif [[ $answer = [Nn] ]]; then
            return 1
        fi
    done
}

# Prompt the user to continue.
if ! promptYesNo "Are you sure you wish to continue?"; then
    echo "Quitting..."
    exit 0
fi

# When creating tmp or log files, append a timestamp so we don't accidentally 
# overwrite anything.
timestamp=$(date +%Y%m%d-%H%M)
# Create file names for a temporary file and a log file.
tmpOutFile="tmpOut-$timestamp.txt"
tmpLogFile="tmpLog-$timestamp.txt"
logFile="log-$timestamp.txt"

# Get all of the Java source files. We need the extra parentheses to make the 
# results into a bash array.
matches=($(find ../ -iname "*.java"))
nMatches=${#matches[@]}

# Prompt the user if they want to do it entirely automatically or if they want
# to fix the documentation in interactive mode (lets them review each file).
promptYesNo "Do you want to review any changes for each file ($nMatches files)?"
interactive=$result

# Process each matched source file.
for match in ${matches[@]}; do
    echo "Scanning file \"$match\"."
    
    # Use the perl script to find and replace everything.
    # Note that the perl script takes input via STDIN, writes the new file to
    # STDOUT, and prints changes to STDERR.
    /usr/bin/perl DocFixer.pl < $match > $tmpOutFile 2> $tmpLogFile
    
    # If there were changes to the file, we should proceed.
    if [ -s $tmpLogFile ]; then
        # This is a helpful message that is not generated by the perl script.
        msg="$(wc -l $tmpLogFile | cut -f 1 -d ' ') changes to file \"$match\""

        # Any updated files should have their changes logged in the main log.
        apply=true
        if [ "$interactive" = true ]; then
            # If interactive mode was selected, we need to prompt the user to 
            # accept changes for each file. Print out the proposed changes.
            echo $msg
            cat $tmpLogFile
            promptYesNo "Update file \"$match\"?"
            apply=$result
        fi

        # Apply the changes as necessary.
        if [ "$apply" = true ]; then
            # Update the master log file with the useful message and the 
            # changes for this file.
            echo $msg >> $logFile
            cat $tmpLogFile >> $logFile
            # Replace the old source file.
            cp $tmpOutFile $match
            echo "File updated."
        else
            echo "File not updated."
        fi
    fi

    # We always need to remove the temporary files.
    rm $tmpOutFile
    rm $tmpLogFile
done

echo "Done."
