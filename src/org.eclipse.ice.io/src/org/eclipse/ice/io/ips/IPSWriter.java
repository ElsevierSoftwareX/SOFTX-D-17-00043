/*******************************************************************************
 * Copyright (c) 2014 UT-Battelle, LLC.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Initial API and implementation and/or initial documentation - Jay Jay Billings,
 *   Jordan H. Deyton, Dasha Gorin, Alexander J. McCaskey, Taylor Patterson,
 *   Claire Saunders, Matthew Wang, Anna Wojtowicz
 *******************************************************************************/
package org.eclipse.ice.io.ips;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.net.InetAddress;
import java.net.UnknownHostException;

import org.eclipse.ice.datastructures.form.Entry;
import org.eclipse.ice.datastructures.form.DataComponent;
import org.eclipse.ice.datastructures.updateableComposite.Component;

public class IPSWriter {

	/**
	 * Nullary constructor
	 */
	public IPSWriter() {
		super();
	}
	
	/**
	 * Writes out an INI file from the given DataComponents to an outputFile.
	 * 
	 * @param components
	 *           An ArrayList of DataComponents holding the data for the INI file.
	 * @param outputFile
	 *           The file to write to.
	 * @throws FileNotFoundException
	 *           Thrown when the output file could not be found.
	 * @throws IOException
	 *           Thrown when writing to OutputStream fails
	 */
	public void writeINIFile(ArrayList<Component> components, File outputFile)
			throws FileNotFoundException, IOException  {
		if (components != null && components.size() > 3 && outputFile.isFile()) {
			OutputStream stream = new FileOutputStream(outputFile);
			int numComponents = components.size();
			
			writeICEHeader(stream);
			writeGlobalConfig((DataComponent) components.get(0), stream);
			writePortsTable((DataComponent) components.get(1), stream);
			for ( int i = 2; i < numComponents-1; i++) {
				writeComponent((DataComponent) components.get(i), stream);
			}
			writeTimeLoopData((DataComponent) components.get(numComponents-1), stream);
			stream.close();
		}
		
	}

	
	/**
	 * Writes an ICE header at the top of the INI file, providing the date, time
	 * and hostname where the file was generated.
	 * 
	 * @param stream
	 *            The OutputStream to write to
	 * @throws UnknownHostException
	 *             Thrown when the host cannot be resolved
	 * @throws IOException
	 *             Thrown when writing to OutputStream fails
	 */
	private void writeICEHeader(OutputStream stream)
			throws UnknownHostException, IOException {
		
		DateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
		String date = dateFormat.format(new Date());
		String user = System.getProperty("user.name");
		String hostname = "";
		hostname = InetAddress.getLocalHost().getHostName();

		String iceHeader = String.format(
				"# *** IPS INI file generated by ICE ***\n"
						+ "#  (Eclipse Integrated Computational Environment)\n"
						+ "#\n" + "#  Created:   %-30s\n"
						+ "#  User:      %-30s\n" + "#  Hostname:  %-30s\n\n\n",
				date, user, hostname);

		// Write to the output stream
		byte[] byteArray = iceHeader.getBytes();
		stream.write(byteArray);

		return;
		
	}

	/**
	 * Takes the Global Configuration DataComponent and extracts each 
	 * of the parameters and writes the contents to the specified
	 * OutputStream.
	 * 
	 * @param component
	 *           The DataComponent containing the global configuration
	 * @param stream
	 *           The OutputStream to write to
	 * @throws IOException
	 *           Thrown when writing to OutputStream fails
	 */
	private void writeGlobalConfig(DataComponent component, OutputStream stream) 
			throws IOException {
		// Get all of the entries
		ArrayList<Entry> globalConfigs = component.retrieveAllEntries();
		String parameter;
		byte[] byteArray;
		// Write the entries as "name = value"
		for ( Entry config : globalConfigs ) {
			parameter = config.getName() + " = " + config.getValue() + "\n";
			byteArray = parameter.getBytes();
			stream.write(byteArray);
		}
	}

	/**
	 * Takes the Ports Table DataComponent and extracts each of the
	 * ports implementation details and writes the contents to the
	 * specified OutputStream.
	 * 
	 * @param component
	 *           The DataComponent containing the ports table
	 * @param stream
	 *           The OutputStream to write to
	 * @throws IOException
	 *           Thrown when writing to OutputStream fails
	 */
	private void writePortsTable(DataComponent component, OutputStream stream) 
			throws IOException {
		// Get all of the entries
		ArrayList<Entry> ports = component.retrieveAllEntries();
		StringBuilder names = new StringBuilder();
		String currLine = "\n[PORTS]\n";
		byte[] byteArray = currLine.getBytes();
		stream.write(byteArray);
		
		// Write the NAMES = PORT1 PORT2 ... section
		names.append("\tNAMES = ");
		for ( Entry port : ports ) {
			names.append(port.getName() + " ");
		}
		names.append("\n\n");
		currLine = names.toString();
		byteArray = currLine.getBytes();
		stream.write(byteArray);
		
		// Write each port entry
		for ( Entry port : ports) {
			// Write the port header
			currLine = "\t[[" + port.getName() + "]]\n";
			byteArray = currLine.getBytes();
			stream.write(byteArray);
			
			// Write the port implementation
			currLine = "\t\tIMPLEMENTATION = " + port.getValue() + "\n";
			byteArray = currLine.getBytes();
			stream.write(byteArray);
		}
		
		// Write a blank line for a spacer
		currLine = "\n";
		byteArray = currLine.getBytes();
		stream.write(byteArray);
		
	}

	/**
	 * Takes a Port Entry DataComponent and extracts each of the
	 * port's implementation details and writes the contents to the
	 * specified OutputStream.
	 * 
	 * @param component
	 *           The DataComponent containing a port entry
	 * @param stream
	 *           The OutputStream to write to
	 * @throws IOException
	 *           Thrown when writing to OutputStream fails
	 */
	private void writeComponent(DataComponent component, OutputStream stream)
			throws IOException {
		// Get the port name and the entries
		String currLine = "[" + component.getName() + "]\n";
		ArrayList<Entry> portParams = component.retrieveAllEntries(); 
		
		// Write the port header
		byte[] byteArray = currLine.getBytes();
		stream.write(byteArray);
		
		// Write each of the port parameters
		for ( Entry param : portParams ) {
			// Write the port header
			currLine = "\t" + param.getName() + " = ";
			byteArray = currLine.getBytes();
			stream.write(byteArray);
			
			// Write the port implementation
			currLine = param.getValue() + "\n";
			byteArray = currLine.getBytes();
			stream.write(byteArray);
		}
		
		// Write a blank line for a spacer
		currLine = "\n";
		byteArray = currLine.getBytes();
		stream.write(byteArray);
	}

	/**
	 * Takes the Time Loop DataComponent and extracts each of the
	 * time loop's implementation details and writes the contents to the
	 * specified OutputStream.
	 * 
	 * @param component
	 *           The DataComponent containing time loop data
	 * @param stream
	 *           The OutputStream to write to
	 * @throws IOException
	 *           Thrown when writing to OutputStream fails
	 */
	private void writeTimeLoopData(DataComponent component, OutputStream stream) 
			throws IOException {
		// Get the port name and the entries
		String currLine = "[TIME_LOOP]\n";
		ArrayList<Entry> timeLoopParams = component.retrieveAllEntries(); 
		
		// Write the port header
		byte[] byteArray = currLine.getBytes();
		stream.write(byteArray);
		
		// Write each of the port parameters
		for ( Entry param : timeLoopParams ) {
			// Write the port header
			currLine = "\t" + param.getName() + " = ";
			byteArray = currLine.getBytes();
			stream.write(byteArray);
			
			// Write the port implementation
			currLine = param.getValue() + "\n";
			byteArray = currLine.getBytes();
			stream.write(byteArray);
		}

	}

}
